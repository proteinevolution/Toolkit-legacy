#!/usr/bin/ruby
require 'optparse'
require 'erb'
require 'yaml'
require 'rubygems'
require 'rsge'

class Submit
  attr_accessor :qm

  def initialize
    @verbose = true
    @mult = 1
    @commands = nil
    @script = nil
    @glob = nil
    @resubmit = nil
    @sge_config = SGE::CONFIGURATION.dup
    @wait = true
    @interval = 3
    @sleep = 0
    @yamlfile = nil
    @qm = SGE::Manager.new

    @commands_stack = []
    @i = 0  # file counter
    @j = 0  # submit counter
  end

  def options
    OptionParser.new do |o|
      o.set_summary_indent('  ')
      o.banner = "Usage: #{$0} [options]"
      o.define_head( "Submit a SGE job via the rsge library.")
      o.separator ""

      o.on("-c", "--commands COMMANDS", String,
           "Comma separated string of commands to be executed." ) do |val|
        @commands = val
      end
      o.on("-s", "--script SCRIPT", String,
           "Absolute path to jobscript to be executed." ) do |val|
        @script = val
      end
      o.on("-m", "--max JOBS", Integer,
           "Maximal number of concurrent jobs (default: #{@sge_config[:max_jobs]})." ) do |val|
        @sge_config[:max_jobs] = val
      end
      o.on("-g", "--glob GLOB", String,
           "Execute job for each file that is matched by the GLOB expression (e.g. *.a3m).",
           'The following substitutions are performed:',
           "FILENAME will be substituted with the full filename of each file matched by GLOB.",
           "BASENAME will be substituted with the basename of FILENAME.",
           "DIRNAME will be substituted with the directory path of FILENAME.",
           "DIRBASENAME will be substituted with DIRNAME/BASENAME.") do |val|
        @glob = val
      end
      o.on("-e", "--exclude EXCLUDE_GLOB", String,
           "Exclude all files whose basename is contained in the basenames of EXCLUDE_GLOB." ) do |val|
        @exglob = val
      end
      o.on("-r", "--resubmit GLOB", String,
           "Resubmit all job scripts matched by GLOB expresssion (e.g. *.sh).") do |val|
        @resubmit = val
      end
      o.on("-y", "--yaml-file FILE", "Optional yaml-file with parameters for grid jobs.") do |val|
        @yamlfile=val
      end
      o.on("-q", "--queue QUEUE", String,
           "Name of queue to which the jobs should be submitted." ) do |val|
        @sge_config[:queue] = val
      end
      o.on("-n", "--name NAME", String,
           "The name prefix of the job." ) do |val|
        @sge_config[:name] = val
      end
      o.on("-p", "--priority PRIO", Integer,
           "Defines or redefines the priority of the job relative to other jobs (PRIO is in the range -1023 to 1024)." ) do |val|
        @sge_config[:priority] = val
      end
      o.on("-l", "--resources RESSOURCE", String,
           "Launch  the job in a queue meeting the given resource request list (format: name=value,...)." ) do |val|
        @sge_config[:ressources] = val
      end
      o.on("-a", "--args ARGS", String,
           "Additional submit arguments to be passed to qsub." ) do |val|
        @sge_config[:args] = val
      end
      o.on("--logfile FILE", String,
           "The name of the logfile to which job outputs should be written (default: #{@sge_config[:jobs_path]}/NAME.log)." ) do |val|
        @sge_config[:logfile] = val
      end
      o.on("--mult JOBS", Integer,
           "Merge multiple jobs into a jobscript to speed up glob-jobs with very quick commands (default: #{@mult})." ) do |val|
        @mult = val
      end
      o.on("--jobspath JOBSPATH", String,
           "Path to which job scripts are written (default: #{@sge_config[:jobs_path]})." ) do |val|
        @sge_config[:jobs_path] = val
      end
      o.on("--sgepath SGEPATH", String,
           "Path to SGE executables (default: #{@sge_config[:sge_path]})." ) do |val|
        @sge_config[:sge_path] = val
      end
      o.on("--no-sync", FalseClass,
           "Do not wait for jobs to finish (default: wait for jobs #{@wait ? 'on' : 'off'})." ) do |val|
        @wait = false
      end
      o.on("--no-check", FalseClass,
           "Turn off error checking (default: error checking #{@sge_config[:error_checking] ? 'on' : 'off'})." ) do |val|
        @sge_config[:error_checking] = false
      end
      o.on("--interval INT", Integer,
           "Update interval for jobs progress table (default: #{@interval} seconds)." ) do |val|
        @interval = val
      end
      o.on("--sleep INT", Integer,
           "Sleep after each job submission  (default: #{@sleep} seconds)." ) do |val|
        @sleep = val
      end
      o.on("--keep-files", TrueClass,
           "Keep jobscripts and outfiles (for debugging, default: keep files #{@sge_config[:keep_files] ? 'on' : 'off'})." ) do |val|
        @sge_config[:keep_files] = true
      end
      o.on("--quiet", "Turn output off.") { |val| @verbose=false }
      o.on("-h", "--help", "Show this help message.") { puts o; exit }
    end
  end

  def run(args=[])
    options.parse!(args)
    if @sge_config[:name].nil?
      if @script
        @sge_config[:name] = File.basename(@script, '.sh')
      elsif @commands
        cmdscript = @commands.split(/\s+/).first
        ext = cmdscript.include?('.') ? cmdscript[-(cmdscript.size-cmdscript.rindex("."))..-1] : ''
        @sge_config[:name] = File.basename(cmdscript, ext)
      else
        @sge_config[:name] = 'STDIN'
      end
    end
    if @sge_config[:logfile].nil? && @glob
      @sge_config[:logfile] = "#{@sge_config[:jobs_path]}/#{@sge_config[:name]}.log"
    end
    @qm.interval = @interval
    @qm.verbose = @verbose
    @qm.set_config(@sge_config)

    if @resubmit
      resubmit_jobs
    else
      process_jobs
    end
    check_for_errors

    self
  end

  def resubmit_jobs
    Dir.glob(@resubmit) do |filename|
      @qm.resubmit(filename)
      sleep @sleep if @sleep>0
      @qm.print_progress($stdout) if @wait
    end
    @qm.print_progress($stdout) if @wait
    if @wait
      @qm.wait
      @qm.print_summary($stdout)
    end
  end

  def process_jobs
    commands = []
    if @script
      # read commands from script
      if File.readable?(@script)
        File.open(@script, 'r') do  |f|
          commands = f.readlines
        end
      else
        puts "Unable to read script file: #{@script}!"
        exit 1
      end
    elsif @commands
      # read commands from provided commands argument
      commands = @commands.strip.split(/;|\n/).map {|cmd| cmd.strip }
    else
      # read commands from standard input
      commands = STDIN.readlines.map {|cmd| cmd.strip }
    end

    if @glob
      excl_basenames = @exglob ? Dir.glob(@exglob).map {|f| File.basename(f, f[-(f.size-f.rindex("."))..-1]) } : []
      @i = 0  # file counter
      @j = 0  # submit counter

      Dir.glob(@glob) do |filename|
        basename = File.basename(filename, filename[-(filename.size-filename.rindex("."))..-1])

        unless excl_basenames.include?(basename)
          dirname = File.dirname(filename)
          cmds = commands.dup
          cmds = cmds.map {|cmd| cmd.gsub(/DIRBASENAME/, "#{dirname}/#{basename}") }
          cmds = cmds.map {|cmd| cmd.gsub(/FILENAME/, filename) }
          cmds = cmds.map {|cmd| cmd.gsub(/BASENAME/, basename) }
          cmds = cmds.map {|cmd| cmd.gsub(/DIRNAME/, dirname) }

          tplvars = Hash.new
          tplvars['dirbasename'] = "#{dirname}/#{basename}"
          tplvars['filename']    = filename
          tplvars['basename']    = basename
          tplvars['dirname']     = dirname

          submit_job(cmds, tplvars)
        end
      end
      # submit remaining jobs regardless of mult setting
      unless @commands_stack.empty?
        @qm.submit(@commands_stack)
        @qm.print_progress($stdout) if @wait
        @commands_stack.clear
      end
    else
      submit_job(commands)
      @qm.print_progress($stdout) if @wait
    end
    @qm.print_progress($stdout) if @wait
    if @wait
      @qm.wait
      @qm.print_summary($stdout)
    end
  end

  def submit_job(cmds, tplvars={})
    #load parameters for grid
    if @yamlfile && File.exists?(@yamlfile)
      fh = File.open(@yamlfile, 'r')
      params = YAML::load(ERB.new(fh.read).result(binding))
      fh.close
    else
      params={}
    end

    #generate commands for parameter grid
    cg = SGE::CommandGenerator.new
    cg.generate(cmds.join("\n"), tplvars, params)

    #submit jobs to queue
    cg.commands.each do |c|
      @i += 1
      @commands_stack.concat(c)

      if @i%@mult==0
        @j += 1
        @qm.submit(@commands_stack)
        @qm.print_progress($stdout) if (@wait && @j%10==0) || @sleep>0
        sleep @sleep if @sleep>0
        @commands_stack.clear
      end
    end
  end

  def check_for_errors
    if !@qm.jobs_error.empty?
      $stderr.puts "There were #{@qm.jobs_error.size} error(s). Check following file(s):"
      @qm.jobs_error.each { |job| $stderr.puts job.outfile }
      exit 1
    end
  end

end

# instantiate script object
s = Submit.new
# handle KILL signal through user abortion
Signal.trap("KILL")  do
  s.qm.kill_all
  exit
end
Signal.trap("INT")  do
  s.qm.kill_all
  exit
end
#start script
s.run(ARGV)
